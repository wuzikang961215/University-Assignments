import java.util.ArrayList;

/* the input is neighbor table and output is the shortest paths of all nodes. Dijkstra algorithm will
 be applied */
class RoutingTable{

    public ArrayList<ArrayList<String>> routingTable; // It saves the shortest path from each router to each other
    public ArrayList<String> shortestPaths; // It saves the shortest paths from one router
    public ArrayList<String> routers3;
    public ArrayList<ArrayList<Integer>> edges3;
    public ArrayList<Integer> shortestStart; // It records next hop of the shortest paths
    public ArrayList<Integer> paths; // It records the shortest paths from one router to each other
    public ArrayList<Integer> unknownPaths; // this records the paths except the already known one
    public ArrayList<Integer> knownIndexes; // this is the known indexes of the shortest routers
    public int shortestDistance; // this is used for comparing between the old shortest paths and new paths
    public int lastRouter;

    // contructor to initialize routers3 and edges3
    public RoutingTable(){
        routers3 = new ArrayList<String>();
        edges3 = new ArrayList<ArrayList<Integer>>();
    }

    // this method recursively calculate the shortest paths from the given router to each other
    public void getShortestPath(int index) {
        int shortestIndex = -1;
        int shortest = -1;
        // this is for updating the neighbor values
        for (int i = 0; i < edges3.get(index).size(); i++) {
            if (edges3.get(index).get(i) != -1) {
                int known = 0; // this is to tell if i is in known indexes or not
                for (int j = 0; j < knownIndexes.size(); j++) {
                    if (i == knownIndexes.get(j)) {
                        known = 1;
                        break;
                    }
                }
                if (known == 0) {
                    int newDistance = shortestDistance + edges3.get(index).get(i);
                    if (paths.get(i) == -1) {
                        paths.set(i, newDistance);
                        unknownPaths.set(i, newDistance);
                        if (lastRouter != -1)
                            shortestStart.set(i, lastRouter);
                    }
                    else {
                        if (newDistance < paths.get(i)) {
                            paths.set(i, newDistance);
                            unknownPaths.set(i, newDistance);
                            shortestStart.set(i, lastRouter);
                        }
                    }
                }
            }
        }
        // this is for finding the next recursion
        for (int i = 0 ; i < unknownPaths.size(); i++) {
            if (unknownPaths.get(i) != -1) {
                if (shortestIndex == -1 || unknownPaths.get(i) < shortest) {
                    shortestIndex = i;
                    shortest = unknownPaths.get(i);
                }
            }
        }
        if (shortestIndex != -1) {
            knownIndexes.add(shortestIndex);
            // if the last router in the path is not the index entered
            shortestDistance = shortest;
            unknownPaths.set(shortestIndex, -1);
            // end the recursion where there is no new paths or all routers are known
            if (knownIndexes.size() < routers3.size()) {
                lastRouter = shortestIndex; // update last router now
                getShortestPath(shortestIndex);
            }
        }
    }

    // this method recursively traces back routers until it gets "next hop"
    public int traceBack(int index, ArrayList<Integer> shortestStart) {
        int returnValue;
        // end the recursion here
        if (shortestStart.get(index) == -1)
            returnValue = index;
        else {
            int nextTrace = shortestStart.get(index);
            returnValue = traceBack(nextTrace, shortestStart);
        }
        return returnValue;
    }

    // this method receives the routers, neighbor table and outputs the routing table
    public void routing(ArrayList<String> routers, ArrayList<ArrayList<Integer>> edges) {
        routingTable = new ArrayList<ArrayList<String>>();
        routers3 = routers;
        edges3 = edges;
        // get shortest paths of all routers
        for (int i = 0; i < routers.size(); i++) {
            knownIndexes = new ArrayList<Integer>();
            knownIndexes.add(i);
            shortestDistance = 0;
            shortestStart = new ArrayList<Integer>();
            // initialize shortest starts
            for (int k = 0; k < routers.size(); k++)
                shortestStart.add(-1);
            paths = new ArrayList<Integer>();
            unknownPaths = new ArrayList<Integer>();
            for (int j = 0; j < routers.size(); j++) {
                paths.add(-1);
                unknownPaths.add(-1);
            }
            lastRouter = -1;
            shortestPaths = new ArrayList<String>();
            getShortestPath(i);
            for (int l = 0; l < shortestStart.size(); l++) {
                if (paths.get(l) != -1)
                    shortestPaths.add(routers3.get(l) + "," + routers3.get(traceBack(l, shortestStart)) + "," + paths.get(l));
            }
            routingTable.add(shortestPaths);
        }
    }

    // this method prints the routing table
    public void printRouting(String router) {
        System.out.println(router + " Routing Table:");
        int index;
        // find out where router is
        for (index = 0; index < routers3.size(); index++) {
            if (routers3.get(index).equals(router))
                break;
        }
        if (routingTable.size() !=0 ) { // only when routing table is not empty
            for (int j = 0; j < routingTable.get(index).size(); j++)
                System.out.println(routingTable.get(index).get(j));
        }
        System.out.println("");
    }
}