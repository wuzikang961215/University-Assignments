import java.util.ArrayList;

/* the input is neighbor table and output is the shortest paths of all nodes. Dijkstra algorithm will
 be applied */
class RoutingNlogN{

    public ArrayList<ArrayList<String>> routingTable; // It saves the shortest path from each router to each other
    public ArrayList<String> shortestPaths; // It saves the shortest paths from one router
    public ArrayList<String> routers3;
    public ArrayList<Neighbors> edges3;
    public ArrayList<Integer> shortestStart; // It records next hop of the shortest paths
    public ArrayList<Integer> paths; // It records the paths from one router to each other
    public ArrayList<Integer> unknownPaths; // this records the paths except the already known one
    public ArrayList<Integer> knownIndexes; // this is the known indexes of the shortest routers
    public int lastRouter; // this variable records the router before
    public int shortestDistance;

    // contructor to initialize routers3 and edges3
    public RoutingNlogN(){
        routers3 = new ArrayList<String>();
        edges3 = new ArrayList<Neighbors>();
    }

    // this method recursively calculate the shortest paths from the given router to each other
    public void getShortestPath(int index) {
        int shortestIndex = -1;
        int shortest = -1;
        for (int i = 0; i < edges3.get(index).neighbors.size(); i++) {
            int indexNow = edges3.get(index).neighbors.get(i).index; // this is the index of ith neighbor
            int known = 0; // this is to tell if i is in known indexes or not
            for (int j = 0; j < knownIndexes.size(); j++) {
                if (indexNow == knownIndexes.get(j)) {
                    known = 1;
                    break;
                }
            }
            if (known == 0) {
                int newDistance = shortestDistance + edges3.get(index).neighbors.get(i).distance;
                if (paths.get(indexNow) == -1) {
                    paths.set(indexNow, newDistance);
                    unknownPaths.set(indexNow, newDistance);
                    if (lastRouter != -1)
                        shortestStart.set(indexNow, lastRouter);
                }
                else {
                    if (newDistance < paths.get(indexNow)) {
                        paths.set(indexNow, newDistance);
                        unknownPaths.set(indexNow, newDistance);
                        shortestStart.set(indexNow, lastRouter);
                    }
                }
            }
        }
        // this is for finding the next recursion
        for (int i = 0 ; i < unknownPaths.size(); i++) {
            if (unknownPaths.get(i) != -1) {
                if (shortestIndex == -1 || unknownPaths.get(i) < shortest) {
                    shortestIndex = i;
                    shortest = unknownPaths.get(i);
                }
            }
        }
        if (shortestIndex != -1) {
            knownIndexes.add(shortestIndex);
            // if the last router in the path is not the index entered
            shortestDistance = shortest;
            unknownPaths.set(shortestIndex, -1);
            // end the recursion where there is no new paths or all routers are known
            if (knownIndexes.size() < routers3.size()) {
                lastRouter = shortestIndex; // update last router now
                getShortestPath(shortestIndex);
            }
        }
    }

    // this method recursively traces back routers until it gets "next hop"
    public int traceBack(int index, ArrayList<Integer> shortestStart) {
        int returnValue;
        // end the recursion here
        if (shortestStart.get(index) == -1)
            returnValue = index;
        else {
            int nextTrace = shortestStart.get(index);
            returnValue = traceBack(nextTrace, shortestStart);
        }
        return returnValue;
    }

    // this method receives the routers, neighbor table and outputs the routing table
    public void routing(ArrayList<String> routers, ArrayList<Neighbors> edges) {
        routingTable = new ArrayList<ArrayList<String>>();
        routers3 = routers;
        edges3 = edges;
        // get shortest paths of all routers
        for (int i = 0; i < routers.size(); i++) {
            knownIndexes = new ArrayList<Integer>();
            knownIndexes.add(i);
            shortestDistance = 0;
            shortestStart = new ArrayList<Integer>();
            // initialize shortest starts
            for (int k = 0; k < routers.size(); k++)
                shortestStart.add(-1);
            paths = new ArrayList<Integer>();
            unknownPaths = new ArrayList<Integer>();
            for (int j = 0; j < routers.size(); j++) {
                paths.add(-1);
                unknownPaths.add(-1);
            }
            lastRouter = -1; // save the last router of the program
            shortestPaths = new ArrayList<String>();
            getShortestPath(i);
            for (int l = 0; l < paths.size(); l++) {
                if (paths.get(l) != -1)
                    shortestPaths.add(routers3.get(l) + "," + routers3.get(traceBack(l, shortestStart)) + "," + paths.get(l));
            }
            routingTable.add(shortestPaths);
        }
    }

    // this method prints the routing table
    public void printRouting(String router) {
        System.out.println(router + " Routing Table:");
        int index;
        // find out where router is
        for (index = 0; index < routers3.size(); index++) {
            if (routers3.get(index).equals(router))
                break;
        }
        if (routingTable.size() !=0 ) { // only when routing table is not empty
            for (int j = 0; j < routingTable.get(index).size(); j++)
                System.out.println(routingTable.get(index).get(j));
        }
        System.out.println("");
    }
}